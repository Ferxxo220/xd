from ucimlrepo import fetch_ucirepo 
  
# fetch dataset 
student_performance = fetch_ucirepo(id=320) 
  
# data (as pandas dataframes) 
X = student_performance.data.features 
y = student_performance.data.targets 
  
# metadata 
print(student_performance.metadata) 
  
# variable information 
print(student_performance.variables) 
-----------------------------------------------------------
import torch
import torch.nn as nn
from torch.utils.data import TensorDataset, DataLoader
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import LabelEncoder
from sklearn.preprocessing import StandardScaler
import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
------------------------------------------------
y = y.drop(["G1", "G2"],axis=1).values
print(X.shape)
print(y.shape)
import numpy as np

def label_g3(g3):
    if g3 < 10:
        return 0      # Reprobado
    elif g3 <= 11:
        return 1      # Suficiente
    elif g3 <= 13:
        return 2      # Bueno
    elif g3 <= 15:
        return 3      # Muy bueno
    else:
        return 4      # Excelente

# y es un array Nx1 con G3.
y_labels = np.array([label_g3(v[0]) for v in y])
------------------------------------------------------
y_labels = y_labels.ravel()
X_encoded = pd.get_dummies(X, drop_first=True)
X_train, X_test, y_train, y_test = train_test_split(X_encoded, y_labels, test_size=0.30, random_state=42, stratify=y_labels)
---------------------------------------------------------------------------------------------------------------------------
scaler = StandardScaler()
X_train = scaler.fit_transform(X_train)
X_test = scaler.transform(X_test)
X_train = torch.FloatTensor(X_train)
X_test = torch.FloatTensor(X_test)
y_train = torch.LongTensor(y_train)
y_test = torch.LongTensor(y_test)
--------------------------------------
class NeuralNetworkClassificationModel(nn.Module):
    def __init__(self,input_dim,output_dim):
        super(NeuralNetworkClassificationModel,self).__init__()
        self.capa_entrada = nn.Linear(input_dim,128) #numero de parametros de entrada 4
        self.capa_oculta = nn.Linear(128,64)
        self.capa_salida = nn.Linear(64,output_dim) #numero de clases de salida 3
        self.relu = nn.ReLU()


    def forward(self,x):
        salida =  self.relu(self.capa_entrada(x)) #capas de entrada
        salida =  self.relu(self.capa_oculta(salida)) #capas ocultas
        salida =  self.capa_salida(salida) #capa de salida
        return salida
-----------------------------------------------------------------------------
input_dim  = 39
output_dim = 5
modeloKFLO = NeuralNetworkClassificationModel(input_dim,output_dim)
learning_rate = 0.01
criterion = nn.CrossEntropyLoss()
optimizer = torch.optim.Adam(modeloKFLO.parameters(),lr=learning_rate)
----------------------------------------------------------------------------
def train_network(model,optimizer,criterion,X_train,y_train,X_test,y_test,num_epochs,train_losses,test_losses):
    for epoch in range(num_epochs):

        optimizer.zero_grad()


        output_train = model(X_train)

        #calcular la perdida
        loss_train = criterion(output_train, y_train)



        #calcular gradiantes
        loss_train.backward()


        optimizer.step()


        output_test = model(X_test)
        loss_test = criterion(output_test,y_test)

        train_losses[epoch] = loss_train.item()
        test_losses[epoch] = loss_test.item()

        if (epoch + 1) % 50 == 0:
            print(f"Epoch {epoch+1}/{num_epochs}, Train Loss: {loss_train.item():.4f}, Test Loss: {loss_test.item():.4f}")
-----------------------------------------------------------------------------------------------------------------------------
num_epochs = 50
train_losses = np.zeros(num_epochs)
test_losses  = np.zeros(num_epochs)
train_network(modeloKFLO,optimizer,criterion,X_train,y_train,X_test,y_test,num_epochs,train_losses,test_losses)
----------------------------------------------------------------------------------------------------------------
predictions_train = []
predictions_test =  []
with torch.no_grad():
    predictions_train = modeloKFLO(X_train)
    predictions_test = modeloKFLO(X_test)
--------------------------------------------------------------------------
def get_accuracy_multiclass(pred_arr,original_arr):
    if len(pred_arr)!=len(original_arr):
        return False
    pred_arr = pred_arr.numpy()
    original_arr = original_arr.numpy()
    final_pred= []

    for i in range(len(pred_arr)):
        final_pred.append(np.argmax(pred_arr[i]))
    final_pred = np.array(final_pred)
    count = 0

    for i in range(len(original_arr)):
        if final_pred[i] == original_arr[i]:
            count+=1
    return count/len(final_pred)
--------------------------------------------------------
train_acc = get_accuracy_multiclass(predictions_train,y_train)
test_acc  = get_accuracy_multiclass(predictions_test,y_test)
print(f"Training Accuracy: {round(train_acc*100,3)}")
print(f"Test Accuracy: {round(test_acc*100,3)}")
